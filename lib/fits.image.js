// Generated by CoffeeScript 1.3.3
(function() {
  var Data, FITS,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  require('jDataView/src/jdataview');

  FITS = this.FITS || require('fits');

  Data = require('fits.data');

  FITS.Image = (function(_super) {

    __extends(Image, _super);

    function Image(view, header) {
      var bitpix, i, naxis,
        _this = this;
      Image.__super__.constructor.apply(this, arguments);
      naxis = header["NAXIS"];
      bitpix = header["BITPIX"];
      this.naxis = [];
      this.rowByteSize = header["NAXIS1"] * Math.abs(bitpix) / 8;
      this.rowsRead = 0;
      this.min = header["DATAMIN"] != null ? header["DATAMIN"] : void 0;
      this.max = header["DATAMAX"] != null ? header["DATAMAX"] : void 0;
      i = 1;
      while (i <= naxis) {
        this.naxis.push(header["NAXIS" + i]);
        i += 1;
      }
      this.length = this.naxis.reduce(function(a, b) {
        return a * b;
      }) * Math.abs(bitpix) / 8;
      this.data = void 0;
      switch (bitpix) {
        case 8:
          this.arrayType = Uint8Array;
          this.accessor = function() {
            return _this.view.getUint8();
          };
          break;
        case 16:
          this.arrayType = Int16Array;
          this.accessor = function() {
            return _this.view.getInt16();
          };
          break;
        case 32:
          this.arrayType = Int32Array;
          this.accessor = function() {
            return _this.view.getInt32();
          };
          break;
        case 64:
          this.arrayType = Int32Array;
          this.accessor = function() {
            var factor, highByte, lowByte, mod, value;
            console.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
            highByte = Math.abs(_this.view.getInt32());
            lowByte = Math.abs(_this.view.getInt32());
            mod = highByte % 10;
            factor = mod ? -1 : 1;
            highByte -= mod;
            value = factor * ((highByte << 32) | lowByte);
            return value;
          };
          break;
        case -32:
          this.arrayType = Float32Array;
          this.accessor = function() {
            return _this.view.getFloat32();
          };
          break;
        case -64:
          this.arrayType = Float64Array;
          this.accessor = function() {
            return _this.view.getFloat64();
          };
          break;
        default:
          throw "FITS keyword BITPIX does not conform to one of the following set values [8, 16, 32, 64, -32, -64]";
      }
    }

    Image.prototype.initArray = function() {
      return this.data = new this.arrayType(this.naxis.reduce(function(a, b) {
        return a * b;
      }));
    };

    Image.prototype.getRow = function() {
      var i, rowLength, _i, _ref;
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      rowLength = this.naxis[0];
      this.view.seek(this.current);
      for (i = _i = 0, _ref = rowLength - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.data[rowLength * this.rowsRead + i] = this.accessor();
      }
      return this.rowsRead += 1;
    };

    Image.prototype.getFrame = function() {
      var i, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.naxis[1] - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.getRow());
      }
      return _results;
    };

    Image.prototype.getFrameWebGL = function() {
      var i, j, rowLength, _i, _j, _ref, _ref1;
      this.data = new Float32Array(this.naxis.reduce(function(a, b) {
        return a * b;
      }));
      this.rowsRead = 0;
      rowLength = this.naxis[0];
      for (j = _i = 0, _ref = this.naxis[1] - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; j = 0 <= _ref ? ++_i : --_i) {
        this.current = this.begin + this.rowsRead * this.rowByteSize;
        this.view.seek(this.current);
        for (i = _j = 0, _ref1 = rowLength - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          this.data[rowLength * this.rowsRead + i] = this.accessor();
        }
        this.rowsRead += 1;
      }
      return this.data;
    };

    Image.prototype.getExtremes = function() {
      var i, index, max, min, value, _i, _j, _ref, _ref1, _ref2;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      index = void 0;
      min = void 0;
      max = void 0;
      for (i = _i = 0, _ref = this.data.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        value = this.data[i];
        if (isNaN(value)) {
          continue;
        }
        min = this.data[i];
        max = this.data[i];
        index = i;
        break;
      }
      for (i = _j = index, _ref1 = this.data.length - 1; index <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = index <= _ref1 ? ++_j : --_j) {
        value = this.data[i];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref2 = [min, max], this.min = _ref2[0], this.max = _ref2[1];
      return [this.min, this.max];
    };

    return Image;

  })(Data);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = FITS.Image;
  }

}).call(this);
