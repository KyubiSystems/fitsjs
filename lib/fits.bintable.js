// Generated by CoffeeScript 1.3.3
(function() {
  var Data, Decompress, FITS,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  require('jDataView/src/jdataview');

  FITS = this.FITS || require('fits');

  Data = require('fits.data');

  Decompress = require('fits.decompress');

  FITS.BinTable = (function(_super) {

    __extends(BinTable, _super);

    BinTable.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    BinTable.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    BinTable.compressedImageKeywords = ["ZIMAGE", "ZCMPTYPE", "ZBITPIX", "ZNAXIS"];

    BinTable.extend(Decompress);

    BinTable.dataAccessors = {
      L: function(view) {
        var value;
        value = view.getInt8() === 84 ? true : false;
        return value;
      },
      X: function(view) {
        throw "Data type not yet implemented";
      },
      B: function(view) {
        return view.getUint8();
      },
      I: function(view) {
        return view.getInt16();
      },
      J: function(view) {
        return view.getInt32();
      },
      K: function(view) {
        var factor, highByte, lowByte, mod, value;
        highByte = Math.abs(view.getInt32());
        lowByte = Math.abs(view.getInt32());
        mod = highByte % 10;
        factor = mod ? -1 : 1;
        highByte -= mod;
        value = factor * ((highByte << 32) | lowByte);
        console.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
        return value;
      },
      A: function(view) {
        return view.getChar();
      },
      E: function(view) {
        return view.getFloat32();
      },
      D: function(view) {
        return view.getFloat64();
      },
      C: function(view) {
        return [view.getFloat32(), view.getFloat32()];
      },
      M: function(view) {
        return [view.getFloat64(), view.getFloat64()];
      }
    };

    function BinTable(view, header) {
      var dataType, i, keyword, match, name, r, value, _i, _ref, _ref1,
        _this = this;
      BinTable.__super__.constructor.apply(this, arguments);
      this.rowByteSize = header["NAXIS1"];
      this.rows = header["NAXIS2"];
      this.length = this.tableLength = this.rowByteSize * this.rows;
      this.compressedImage = header.contains("ZIMAGE");
      this.rowsRead = 0;
      if (this.compressedImage) {
        this.length += header["PCOUNT"];
        this.cmptype = header["ZCMPTYPE"];
        this.bitpix = header["ZBITPIX"];
        this.naxis = header["ZNAXIS"];
        this.nx = header.contains("ZTILE1") ? parseInt(header["ZTILE1"]) : header["ZNAXIS1"];
        this.bzero = header.contains("BZERO") ? header["BZERO"] : 0;
        if (this.cmptype === "RICE_1") {
          i = 1;
          while (true) {
            if (!header.contains("ZNAME" + i)) {
              break;
            }
            name = header["ZNAME" + i];
            value = header["ZVAL" + i];
            if (name === "BLOCKSIZE") {
              this.blocksize = value;
            } else if (name === "BYTEPIX") {
              this.bytepix = value;
            }
            i += 1;
          }
          if (!this.blocksize) {
            this.blocksize = 32;
          }
          if (!this.bytepix) {
            this.bytepix = 4;
          }
        } else {
          throw "Compression algorithm not yet implemented.";
        }
      }
      this.fields = parseInt(header["TFIELDS"]);
      this.accessors = [];
      for (i = _i = 1, _ref = this.fields; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        keyword = "TFORM" + i;
        value = header[keyword];
        match = value.match(BinTable.arrayDescriptorPattern);
        if (match != null) {
          (function() {
            var accessor, dataType;
            dataType = match[1];
            accessor = function() {
              var data, length, offset, _j;
              length = _this.view.getInt32();
              offset = _this.view.getInt32();
              _this.current = _this.view.tell();
              _this.view.seek(_this.begin + _this.tableLength + offset);
              data = [];
              for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                data.push(BinTable.dataAccessors[dataType](_this.view));
              }
              _this.view.seek(_this.current);
              return data;
            };
            return _this.accessors.push(accessor);
          })();
        } else {
          match = value.match(BinTable.dataTypePattern);
          _ref1 = match.slice(1), r = _ref1[0], dataType = _ref1[1];
          r = r ? parseInt(r) : 0;
          if (r === 0) {
            (function() {
              var accessor;
              dataType = match[2];
              accessor = function(dt) {
                var data;
                data = BinTable.dataAccessors[dataType](_this.view);
                return data;
              };
              return _this.accessors.push(accessor);
            })();
          } else {
            (function() {
              var accessor;
              dataType = match[2];
              accessor = function() {
                var data, _j;
                data = [];
                for (i = _j = 1; 1 <= r ? _j <= r : _j >= r; i = 1 <= r ? ++_j : --_j) {
                  data.push(BinTable.dataAccessors[dataType](_this.view));
                }
                return data;
              };
              return _this.accessors.push(accessor);
            })();
          }
        }
      }
    }

    BinTable.prototype.getRow = function() {
      var data, i, row, _i, _ref;
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = [];
      for (i = _i = 0, _ref = this.accessors.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        data = this.accessors[i]();
        row.push(data);
      }
      this.rowsRead += 1;
      if (this.compressedImage) {
        console.log(this.riceDecompressShort(data));
      }
      return row;
    };

    BinTable.prototype.riceDecompressShort = function(arr) {
      var b, bbits, bytevalue, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pixels, _i, _ref;
      pixels = new Uint16Array(this.nx);
      fsbits = 4;
      fsmax = 14;
      bbits = 1 << fsbits;
      nonzeroCount = new Array(256);
      nzero = 8;
      k = 128;
      i = 255;
      while (i >= 0) {
        while (i >= k) {
          nonzeroCount[i] = nzero;
          i -= 1;
        }
        k = k / 2;
        nzero -= 1;
      }
      nonzeroCount[0] = 0;
      lastpix = 0;
      bytevalue = arr.shift();
      lastpix = lastpix | (bytevalue << 8);
      bytevalue = arr.shift();
      lastpix = lastpix | bytevalue;
      b = arr.shift();
      nbits = 8;
      i = 0;
      while (i < this.nx) {
        nbits -= fsbits;
        while (nbits < 0) {
          b = (b << 8) | (arr.shift());
          nbits += 8;
        }
        fs = (b >> nbits) - 1;
        b &= (1 << nbits) - 1;
        imax = i + this.blocksize;
        if (imax > this.nx) {
          imax = this.nx;
        }
        if (fs < 0) {
          while (i < imax) {
            arr[i] = lastpix;
            i++;
          }
        } else if (fs === fsmax) {
          while (i < imax) {
            k = bbits - nbits;
            diff = b << k;
            k -= 8;
            while (k >= 0) {
              b = arr.shift();
              diff |= b << k;
              k -= 8;
            }
            if (nbits > 0) {
              b = arr.shift();
              diff |= b >> (-k);
              b &= (1 << nbits) - 1;
            } else {
              b = 0;
            }
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            arr[i] = diff + lastpix;
            lastpix = arr[i];
            i++;
          }
        } else {
          while (i < imax) {
            while (b === 0) {
              nbits += 8;
              b = arr.shift();
            }
            nzero = nbits - nonzeroCount[b];
            nbits -= nzero + 1;
            b ^= 1 << nbits;
            nbits -= fs;
            while (nbits < 0) {
              b = (b << 8) | (arr.shift());
              nbits += 8;
            }
            diff = (nzero << fs) | (b >> nbits);
            b &= (1 << nbits) - 1;
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            pixels[i] = diff + lastpix;
            lastpix = pixels[i];
            i++;
          }
        }
      }
      for (i = _i = 0, _ref = pixels.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        pixels[i] = pixels[i] + this.bzero;
      }
      return pixels;
    };

    return BinTable;

  })(Data);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = FITS.BinTable;
  }

}).call(this);
