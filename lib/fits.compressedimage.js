// Generated by CoffeeScript 1.3.3
(function() {
  var Data, Decompress, FITS,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  require('jDataView/src/jdataview');

  FITS = this.FITS || require('fits');

  Data = require('fits.data');

  Decompress = require('fits.decompress');

  FITS.CompImage = (function(_super) {

    __extends(CompImage, _super);

    CompImage.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    CompImage.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    CompImage.compressedImageKeywords = ["ZIMAGE", "ZCMPTYPE", "ZBITPIX", "ZNAXIS"];

    CompImage.extend(Decompress);

    CompImage.typeArray = {
      B: Uint8Array,
      I: Int16Array,
      J: Int32Array,
      1: Uint8Array,
      2: Uint8Array,
      4: Int16Array,
      8: Int32Array
    };

    CompImage.dataAccessors = {
      L: function(view) {
        var value;
        value = view.getInt8() === 84 ? true : false;
        return value;
      },
      X: function(view) {
        throw "Data type not yet implemented";
      },
      B: function(view) {
        return view.getUint8();
      },
      I: function(view) {
        return view.getInt16();
      },
      J: function(view) {
        return view.getInt32();
      },
      K: function(view) {
        var factor, highByte, lowByte, mod, value;
        highByte = Math.abs(view.getInt32());
        lowByte = Math.abs(view.getInt32());
        mod = highByte % 10;
        factor = mod ? -1 : 1;
        highByte -= mod;
        value = factor * ((highByte << 32) | lowByte);
        console.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
        return value;
      },
      A: function(view) {
        return view.getChar();
      },
      E: function(view) {
        return view.getFloat32();
      },
      D: function(view) {
        return view.getFloat64();
      },
      C: function(view) {
        return [view.getFloat32(), view.getFloat32()];
      },
      M: function(view) {
        return [view.getFloat64(), view.getFloat64()];
      }
    };

    function CompImage(view, header) {
      var dataType, i, key, keyword, match, r, ttype, value, ztile, _i, _j, _ref, _ref1, _ref2,
        _this = this;
      CompImage.__super__.constructor.apply(this, arguments);
      this.rowByteSize = header["NAXIS1"];
      this.rows = header["NAXIS2"];
      this.length = this.tableLength = this.rowByteSize * this.rows;
      this.rowsRead = 0;
      this.length += header["PCOUNT"];
      this.zcmptype = header["ZCMPTYPE"];
      this.zbitpix = header["ZBITPIX"];
      this.znaxis = header["ZNAXIS"];
      this.ztile = [];
      for (i = _i = 1, _ref = this.znaxis; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        ztile = header.contains("ZTILE" + i) ? header["ZTILE" + i] : i === 1 ? header["ZNAXIS1"] : 1;
        this.ztile.push(ztile);
      }
      this.algorithmParameters = {};
      i = 1;
      while (true) {
        key = "ZNAME" + i;
        if (!header.contains(key)) {
          break;
        }
        value = "ZVAL" + i;
        this.algorithmParameters[header[key]] = header[value];
        i += 1;
      }
      this["setDefaultParameters_" + this.zcmptype]();
      this.zmaskcmp = FITS.CompImage.setValue(header, "ZMASKCMP", void 0);
      this.zquantiz = FITS.CompImage.setValue(header, "ZQUANTIZ", "LINEAR_SCALING");
      this.bzero = FITS.CompImage.setValue(header, "BZERO", 0);
      this.bscale = FITS.CompImage.setValue(header, "BSCALE", 1);
      this.fields = header["TFIELDS"];
      this.accessors = [];
      for (i = _j = 1, _ref1 = this.fields; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        keyword = "TFORM" + i;
        value = header[keyword];
        match = value.match(FITS.CompImage.arrayDescriptorPattern);
        ttype = header["TTYPE" + i];
        if (match != null) {
          if (ttype === "COMPRESSED_DATA") {
            (function() {
              var accessor, dataType;
              dataType = match[1];
              accessor = function() {
                var data, length, offset, pixels, _k;
                length = _this.view.getInt32();
                offset = _this.view.getInt32();
                _this.current = _this.view.tell();
                _this.view.seek(_this.begin + _this.tableLength + offset);
                data = new FITS.CompImage.typeArray[dataType](length);
                for (i = _k = 1; 1 <= length ? _k <= length : _k >= length; i = 1 <= length ? ++_k : --_k) {
                  data[i - 1] = FITS.CompImage.dataAccessors[dataType](_this.view);
                }
                _this.view.seek(_this.current);
                pixels = new FITS.CompImage.typeArray[_this.algorithmParameters["BYTEPIX"]](_this.ztile[0]);
                FITS.CompImage.rice(data, length, _this.algorithmParameters["BLOCKSIZE"], _this.algorithmParameters["BYTEPIX"], pixels, _this.ztile[0]);
                return pixels;
              };
              return _this.accessors.push(accessor);
            })();
          } else {
            (function() {
              var accessor, dataType;
              dataType = match[1];
              accessor = function() {
                var data, length, offset, _k;
                length = _this.view.getInt32();
                offset = _this.view.getInt32();
                _this.current = _this.view.tell();
                _this.view.seek(_this.begin + _this.tableLength + offset);
                data = [];
                for (i = _k = 1; 1 <= length ? _k <= length : _k >= length; i = 1 <= length ? ++_k : --_k) {
                  data.push(FITS.CompImage.dataAccessors[dataType](_this.view));
                }
                _this.view.seek(_this.current);
                return data;
              };
              return _this.accessors.push(accessor);
            })();
          }
        } else {
          match = value.match(FITS.CompImage.dataTypePattern);
          _ref2 = match.slice(1), r = _ref2[0], dataType = _ref2[1];
          r = r ? parseInt(r) : 0;
          if (r === 0) {
            (function() {
              var accessor;
              dataType = match[2];
              accessor = function() {
                return FITS.CompImage.dataAccessors[dataType](_this.view);
              };
              return _this.accessors.push(accessor);
            })();
          } else {
            (function() {
              var accessor;
              dataType = match[2];
              accessor = function() {
                var data, _k;
                data = [];
                for (i = _k = 1; 1 <= r ? _k <= r : _k >= r; i = 1 <= r ? ++_k : --_k) {
                  data.push(FITS.CompImage.dataAccessors[dataType](_this.view));
                }
                return data;
              };
              return _this.accessors.push(accessor);
            })();
          }
        }
      }
    }

    CompImage.prototype.setDefaultParameters_RICE_1 = function() {
      if (!this.algorithmParameters.hasOwnProperty("BLOCKSIZE")) {
        this.algorithmParameters["BLOCKSIZE"] = 32;
      }
      if (!this.algorithmParameters.hasOwnProperty("BYTEPIX")) {
        return this.algorithmParameters["BYTEPIX"] = 4;
      }
    };

    CompImage.setValue = function(header, key, defaultValue) {
      if (header.contains(key)) {
        return header[key];
      } else {
        return defaultValue;
      }
    };

    CompImage.prototype.getRow = function() {
      var data, i, pixels, row, scale, zero, _i, _j, _ref, _ref1;
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = [];
      for (i = _i = 0, _ref = this.accessors.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        row.push(this.accessors[i]());
      }
      this.rowsRead += 1;
      data = row[0];
      scale = row[1][0];
      zero = row[2][0];
      pixels = new Float32Array(data.length);
      for (i = _j = 0, _ref1 = data.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        pixels[i] = (data[i] * scale) + zero;
      }
      return pixels;
    };

    CompImage.prototype.getFrame = function() {
      var data, i, pixels, row, scale, zero, _i, _j, _ref, _ref1;
      this.rowsRead = 0;
      pixels = new Float32Array(this.ztile[0] * this.rows);
      while (true) {
        this.current = this.begin + this.rowsRead * this.rowByteSize;
        this.view.seek(this.current);
        row = [];
        for (i = _i = 0, _ref = this.accessors.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          row.push(this.accessors[i]());
        }
        this.rowsRead += 1;
        data = row[0];
        scale = row[1][0];
        zero = row[2][0];
        for (i = _j = 0, _ref1 = data.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          pixels[i + this.rowsRead * this.ztile[0]] = (data[i] * scale) + zero;
        }
        if (this.rowsRead === this.rows) {
          break;
        }
      }
      return pixels;
    };

    CompImage.subtractiveDither1 = function() {
      throw "Not yet implemented";
    };

    CompImage.linearScaling = function() {
      throw "Not yet implemented";
    };

    return CompImage;

  })(Data);

  if (typeof module !== "undefined" && module !== null) {
    module.exports = FITS.CompImage;
  }

}).call(this);
